use farmfe_toolkit::regex::Regex;
use farmfe_utils::relative;
use std::{
  fs::{self, File},
  io::{self, BufWriter, Write},
  path::Path,
};

use super::parse::ExportType;
use super::scan_exports::Import;

pub struct GenerateDtsOption<'a> {
  pub imports: &'a Vec<&'a Import>,
  pub presets_imports: &'a Vec<&'a Import>,
  pub root_path: String,
  pub filename: String,
}

pub fn remove_tsx_jsx_suffix(s: &str) -> String {
  let re = Regex::new(r"\.[tj]sx$").unwrap();
  re.replace(s, "").into_owned()
}

pub fn stringify_presets(item: &Import) -> String {
  format!(
    "\tconst {}: typeof import('{}')['{}']\n",
    item.as_name.clone().unwrap_or(item.name.clone()), item.form, item.name
  )
}

pub fn stringify_imports_dts(dts_file_path: &str, item: &Import) -> String {
  let related = format!("./{}", relative(dts_file_path, &item.form));
  let import_path = remove_tsx_jsx_suffix(&related);
  let is_export_decl = match item.export_type {
    ExportType::DefaultDecl => false,
    _ => true,
  };
  let mut target = "default";
  if is_export_decl {
    target = &item.name;
  }
  format!(
    "\tconst {}: typeof import('{}')['{}']\n",
    item.as_name.clone().unwrap_or(item.name.clone()),
    import_path,
    target
  )
}

pub fn generate_dts(option: GenerateDtsOption) {
  let mut code =
    "/* generated by farmfe_plugin_auto_import */\nexport {} \ndeclare global {\n".to_string();
  let dts_output = Path::new(&option.root_path).join(&option.filename);
  code.push_str(
    &option
      .imports
      .iter()
      .map(|&s| stringify_imports_dts(dts_output.parent().unwrap().to_str().unwrap(), s))
      .collect::<Vec<_>>()
      .join(""),
  );
  code.push_str(
    &option
      .presets_imports
      .iter()
      .map(|&item| stringify_presets(item))
      .collect::<Vec<_>>()
      .join(""),
  );

  code.push_str("}");

  let file = create_file(dts_output).unwrap();
  let mut writer = BufWriter::new(file);
  writeln!(writer, "{}", code).unwrap();
  writer.flush().unwrap();
}

fn create_file<P: AsRef<Path>>(file_path: P) -> io::Result<File> {
  let path = file_path.as_ref();
  if let Some(parent) = path.parent() {
    fs::create_dir_all(parent)?;
  }

  File::create(path)
}
#[cfg(test)]
mod tests {
  use super::*;
  use crate::parser::scan_dirs_exports::scan_dir_exports;
  use crate::presets::resolve_presets;
  use crate::presets::PresetItem;

  use std::env;
  #[test]
  fn test_generate_dts() {
    let current_dir = env::current_dir().unwrap();
    let binding = current_dir.join("playground-vue");
    let root_path = binding.to_str().unwrap();
    let imports = scan_dir_exports(root_path);
    println!("imports: {:#?}", imports);

    let presets_imports = resolve_presets(&vec![PresetItem::String("react-router".to_string())]);
    let generate_dts_option = GenerateDtsOption {
      imports: &imports.iter().collect::<Vec<_>>(),
      presets_imports: &presets_imports.iter().collect::<Vec<_>>(),
      root_path: root_path.to_string(),
      filename: "src/types/auto_import.d.ts".to_string(),
    };
    generate_dts(generate_dts_option);
    // assert!(!components.is_empty(), "Components should not be empty");
  }
}
